## iOS面试题难点集锦（二）---参考答案

引言：通过上篇文章[iOS面试题难点集锦（二）](https://github.com/LiuFuBo/iOSInterviewQuestions/blob/master/iOS面试题难点集锦/iOS面试题难点集锦（二）.md)，我们了解了一些散碎的iOS知识点，接下来的篇幅我们会着重讲解一些体系内文章。

# 索引

1. [HTTP工作原理图](#HTTP工作原理图 ) 
2. [HTTP/0.9版本篇](#HTTP/0.9版本篇 )
3. [HTTP/1.0版本篇](#HTTP/1.0版本篇 )
4. [HTTP/1.1版本篇](#HTTP/1.1版本篇 )
5. [HTTP/2.0版本篇](#HTTP/2.0版本篇 )
6. [HTTPS版本篇](#HTTPS版本篇 )
7. [SSL/TLS协议介绍](#SSL/TLS协议介绍 )




### HTTP发展历程？

HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（www.world wide web）服务器传输超文本到本地浏览器的传输协议。HTTP是基于TCP/IP的应用层协议。不涉及到数据包(packet)传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。  



#### HTTP工作原理图  

![](http://brandonliu.pub/icon_blog_wanweiwang_http.jpg)  



#### HTTP/0.9版本篇  



#### 要点  

* 客户端向服务器请求网页，服务器只能回应HTML格式字符串，不能回应别的格式。  
* 只有GET请求方式。  
* 服务器发送完毕，就关闭TCP连接。  
* 任何格式内容都可以发送—(包括文字、图像、视频、二进制文件)。  


#### 缺点  

* 每个TCP连接只能发送一个请求；发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。  
* TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢。  
* 网页加载的外部资源越多，性能就越差。  
* 只有GET这一种请求方式。  


#### HTTP/1.0版本篇  



#### 要点  

* 除了GET请求格式，还引入了POST和HEAD格式，丰富了浏览器与服务器交互方式。  
* HTTP请求和回应格式发生改变，除了数据部分，每次通信都包括头部分，用来描述数据。  
* 新增功能包括：状态码、多字符集支持、多部分发送、权限、缓存、内容编码等。  


```

HTTP/1.0请求的例子：

GET/HTTP/1.0 
USER-AGENT:MOZILLA/5.0(MACINTOSH;INTEL MAC OS X 10_10_5 ) 
ACCEPT:*/*
第一行为请求命令,必须在尾部添加协议版本(HTTP/1.0)
后面为多行头信息，描述客户端情况

```


```

HTTP/1.0回应的例子：
HTTP/1.0 200 OK              /*协议版本+状态码+状态描述*/
CONTENT-TYPE: TEXT/PLAIN   
CONTENT-LENGTH: 137582
EXPIRES: THU, 05 DEC 1997 16:00:00 GMT
LAST-MODIFIED: WED, 5 AUGUST 1996 15:55:28 GMT
SERVER: APACHE 0.84

<HTML>
  <BODY>HELLO WORLD</BODY>
</HTML>
CONTENT-TYPE:字符编码，HTTP 1.0规定 头部必须是ASCII码，后面可以是任何格式，
因此，服务器回应时，CONTENT-TYPE的作用是：告诉客户端，数据是什么格式

```



#### 缺点  

* 每个TCP连接只能发送一个请求；发送数据完毕，连接关闭，如果还要请求其他资源，必须再新建一个连接。  
* TCP新建成功很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢。（为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段，即：CONNECTION:KEEP-ALIVE）请求服务器不要关闭TCP连接，以便其他请求复用，服务器同样回复这个字段；以实现TCP的复用，直到客户端或服务器主动关闭连接，但这不是标准字段，不同实现的行为可能导致不一致，因此不是根本的解决办法。  
* 网页加载外部资源越多，性能越差。  


#### HTTP/1.1版本篇  



##### 要点  


* 引入持久连接  

```

1.持久连接定义：即TCP连接默认不关闭，可以被多个请求复用，不用声明。
2.引入方式：CONNECTION:KEEP-ALINE
3.关闭连接：客户端和服务器发现对方有单时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时明确要求服务器关闭TCP连接。CONNECTION:CLOSE
4.对于同一个域名，大多数浏览器允许同事简历6个持久连接。

```

* 引入管道机制  


```
1.管道机制：在同一个TCP连接里面，客户端可以同时发送多个请求。（提高HTTP协议的效率）
例：客户端需要请求两个资源，HTTP 1.0是在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发送B请求；管道机制是允许浏览器同时发生A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。
2.一个TCP连接可以传送多个回应，势必要有机制区分数据包属于哪个回应；则需要Content-length字段，它的作用就是声明本次回应数据长度。（服务器发送回应之前，必须知道回应数据长度）

```

* 采用分块传输编码  

```
1.使用Content-length字段前提是服务器发送回应之前，必须知道回应数据长度。但对于一些耗时的动态操作，意味着，服务器要等待所有操作完成，才能发送数据，显然效率不高。
2.更好的处理方式是：服务器每产生一块数据，就发送一块，采用"流模式 (stream)"取代"缓存模式（buffer）"，因此，HTTP/1.1版本规定可以不使用Content-length字段，而使用"分块传输编码"，只要请求或回应的头信息有Transfer-Encoding字段，就表明回应的数据将有数量未定的数据块组成，最后是一个大小为0的块，就标识本次回应的数据发送完毕。

```


* 新增 PUT、PATCH、HEAD、OPTIONS、DELECT.客户端的头信息增加HOST字段，用来自定指定服务器的域名。HOST:WWW.EXAMPLE.COM 有了HOST字段，就可以将请求发往同一台服务器的不同网站，为虚拟主机新起打下了基础。  


#### 缺点  


* 虽然复用TCP连接，但是在同一个TCP连接里面，所有的数据通信都是按照次序进行的。服务器只有处理完一个回应，才能进行下一个回应。  


```
解决方案：
1.减少HTTP请求数。
2.同事多开持久连接。

```

#### HTTP/2.0版本篇  



#### 要点  


* 采用二进制协议  


```
1.HTTP/1.1的头信息是文本(ASCII编码)， 数据体可以是文本（解析非常麻烦），也可以是二进制。
2.HTTP/2.0则是一个彻底的二进制协议，头信息和数据体都是二进制，统称为"帧（frame）:头信息帧、数据帧"。二进制协议有一个好处是可以定义额外的帧，方便解析。

```

* 多路复用（双向，实时的通信）  


```
HTTP/2.0复用TCP连接，在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而不用按照顺序一一对应，这样就避免"队头阻塞"。
例：在一个TCP连接里面，服务器同时受到A请求和B请求，先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分，接着回应B请求，完成后，才发送B请求剩下的部分。

```

* 数据流  


```
1.HTTP/2.0数据流是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此必须要对数据包标记，指出它属于哪个回应。
2.HTTP/2.0将每一个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据ID，用于区分它数据哪一个数据流；另外规定：客户端发出的数据流，ID一律为奇数，服务器发送的，ID为偶数。
3.数据流发送一半时，客户端和服务器都可以发送信号，取消这个数据流。即HTTP/2.0可以取消某一个请求，同事保证TCP连接还开着，可以被其他请求使用。客户端还可以指定数据流的优先级，优先级越高，服务器就越早回应。

````


* 头信息压缩  


```
1.HTTP/2.0以前的版本协议不带有状态，每次请求都必须附带上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent一模一样，每次请求都必须附带，这很浪费宽带，也影响速度。
2.HTPP/2.0优化了这一点，引入了投信息压缩机制，一方面头信息使用gzip或者compress压缩后再发送，另一方面，客户端和服务端同事维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段，只发送索引号，提高速度。

```

* 服务器推送  


```
1.HTTP/2.0允许服务器未经允许，主动向客户端发送资源。
例：客户端请求一个网页，这个网页里面包含静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发送静态资源请求；其实服务器可以预期到客户端请求网页后，很可能再请求静态资源，所以主动把这些静态资源随网页一起发送给客户端。

````


#### 缺点   


* 请求太多时也需要排队。  


#### HTTPS版本篇



#### 要点  


* HTTPS 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。  
* HTTPS协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。   
* HTTPS的SSL加密是在传输层实现的。  



#### 握手流程图：  


![](http://brandonliu.pub/icon_blog_woshou_http.jpeg) 



#### 工作原理  

* 客户端-->服务器 发起请求  

```
1.客户端发起请求到服务器。主要参数是支持的协议版本，加密方法以及一个随机数n1。

``` 

* 服务器-->客户端 发送证书，客户端验证证书。  

```
1.服务器收到请求并确认加密方法，然后返回公钥，以及一个由服务器生成的随机数n2;在这个阶段iOS中的CA认证的认证的证书会自动验证，而私有的证书则需要手动验证放行，否则拒绝链接

```

* 客户端-->服务器 发送消息  


```
1.客户端验证证书成功后会生成第三个随机数n3，并用第2步服务器返回的证书对该随机数加密，并发送给服务器，同时也会发送一些其他信息，比如：编码信息和客户端握手结束的通知。

````


* 服务器-->客户端 发送信息  

```
服务器用私钥解密后，得到客户端传来的第三个随机数n3,两端使用这三个随机数n1、n2、n3来生成Session Key。服务器向客户端发送编码信息和服务器握手结束通知。

```

* 完整性验证  


```
完整性验证以后，后面的信息传输就靠这个Session key进行对称加密了。  

```



#### SSL在握手的过程中主要交换了以下三个信息：  


* 加密通信协议：就是双方商量使用哪一种加密方式，假如两者支持的加密方式不匹配，则无法进行通信。  
* 数字证书：该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证。  
* 三个随机数n1,n2,n3:这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的对话密钥。  



#### 优点  


* 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。  
* HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。  
* HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。  




#### 缺点  


* HTTPS握手阶段比较费时，会使页面加载时间延长50%，增加10%-20%的耗电。  
* HTTPS缓存不如HTTP高效，会增加数据开销。  
* SSL证书也需要钱，功能越强大的证书费用越高。  
* SSL证书需要绑定IP，不能再同一个IP上绑定多个域名，IPV4资源支持不了这种消耗。  



#### SSL/TLS协议介绍  

互联网的通信安全是建立在SSL/TLS协议之上。不使用SSL/TLS的HTTP协议，就是不加密的通信；会带来三大风险：  

* 窃听风险：第三方可以获取通信内容。—（截取银行卡、各种密码、手机号等）  
* 篡改风险：第三方可以修改通信内容。 —（劫持插入广告）  
* 冒失风险：第三方可以冒充他人身份参与通信。—（遭遇伪装服务器通信）  



#### SSL/TLS就是为了解决这三大风险而设计的，希望达到：  

* 所有信息都是加密传播，第三方无法窃听。  
* 具有校验机制，一旦被篡改，通信双方立即发现。  
* 配备身份证书，防止身份被冒充。  



#### SSL/TLS协议的基本思路  


* 公钥加密法：即客户端先向服务端索要公钥，然后用公钥加密信息，客户端收到密文后，用自己的私钥解密。  


#### 如何保证公钥不被篡改？  


* 解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。  


#### 公钥加密计算量太大，如何减少耗用的时间？  


* 解决方法：每一次对话（SESSION），客户端和服务器端都生成一个"对话密钥"（SESSION KEY），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。  

#### HTTPS协议耗时原因？  

* HTTP耗时 = TCP握手；HTTPS耗时 = TCP握手 + SSL握手 所以，HTTPS肯定比HTTP耗时，这就叫SSL延迟  


#### 中间人攻击  


中间人攻击是通过与客户端、服务器分别建立连接，来获得了明文的信息攻击方式。在这个过程中，客户端与服务器的通信被第三方解密、查看、修改。  


#### 原理图：  


![](http://brandonliu.pub/icon_blog_gongji_http.jpeg)



#### 为什么有些APP即便使用了HTTPS，还是会被中间人攻击呢？  


基本都是因为没做客户端验证，特别是在使用未经CA认证的证书时，更容易中招。关于黑客是如何在协议握手初期劫持服务，从而实现中间人攻击，可以做如下推演:  

* 黑客劫持到服务器公钥，并冒充客户端与服务器连接。  
* 黑客自己生成公钥，冒充服务器公钥返回给真正的客户端。  


如果客户端未做验证的话，就不会发现证书被替换，于是客户端会用黑客的公钥发送数据，黑客劫持数据后，用自己的私钥解密。   



#### 如何防止中间人攻击？  


* 把证书打包进APP，然后与服务器返回的证书对比验证，验证成功以后才允许连接。当然是用这种方式会导致一些问题，比如：当证书过期时APP连不上服务器，这时需要我们将新证书提前打包进APP。  
* 通过Socket通道从服务器传送证书进APP中，来实现无缝对接。






















